Indices negativos:

-1 : se refiere al ultimo elemento.
-2 : se refiere al penultimo elemento.
-3 : se refiere al antepenultimo elemento. 
.
.
.
asi sucesivamente.


Inputs: input(" ") # se usa para obtener un input.


CONDICIONALES:

if, elif, else:

edad = 18

if edad >= 18:
    print("Eres mayor de edad")

else:
    print("No eres mayor de edad")


ELIF : se usa cuando la condicion anterior es falsa pasa a la siguiente

if condición_1:
    # Código si condición_1 es verdadera
elif condición_2:
    # Código si condición_1 es falsa y condición_2 es verdadera
elif condición_3:
    # Código si las condiciones anteriores son falsas y condición_3 es verdadera
else:
    # Código si todas las condiciones anteriores son falsas

nota = 85

if nota >= 90:
    print("A")
elif nota >= 80:
    print("B")
elif nota >= 70:
    print("C")
else:
    print("F")



BUCLES: 

    FOR: 
    Se usa para iterar sobre una secuencia (lista, diccionario, conjunto o cadenas de texto).

        Sintaxis basica: 
        
            for item in iterable:
                # Bloque código

    iterable: cualquier objeto sobre el que puedas iterar (listas, rangos, diccionarios, etc.)
    item: variable que tomara el valor de cada elemento en la secuencia uno a uno en cada iteracion.


    range(): cuando se necesitan un numero especifico de iteraciones.

    Ejemplo:

        for i in range(5):
            print(i) # Imprime del 0 al 4

    Tambien se puede usar start, stop, step:

        for i in range(2, 10, 2)
        print(i) # Imprime 2, 4, 6, 8

    El numero del final es decir el step que en este caso es el 2 seria el start + step:
        En este caso empieza en el 2, luego seria el 4, y asi hasta 10 porque es el stop.


    WHILE:
    Sigue ejecutando un bloque de codigo mientras esa condicion sea verdadera.
    Este tipo de codigo es comun cuando no sabes cuantas veces vas a iterar de antemano pero si sabiendo que condicion.

        Sintaxis basica:

            while condicion:
                # Bloque código


            La condicion es evaluada antes de cada iteracion. Si la condicion es verdadera, el cuerpo del codigo seguira ejecutandose,
            si es falsa se termina el bucle.


        Ejemplo:

            contador 0

            while contador < 5:
                print(contador)
                contador += 1 # Aseguramos que la condicion eventualmente sea falsa.



CONTROL DE FLUJO EN BUCLES:
    En Python hay res tipos de sentencias principales: break, continue, else.

    BREAK: Sale del bucle, independientemente de si la condición sigue siendo verdadera o no.

    Ejemplo:

        for i in range(10):
            if i == 5:
                break  # Sale del bucle cuando i es igual a 5
                print(i)

    CONTINUE: Salta la iteración actual y continúa con la siguiente iteración del bucle.

    Ejemplo:

        for i in range(5):
            if i == 2:
        continue  # Salta el 2 y continúa con el siguiente valor
            print(i)

    ELSE: Los bucles for y while pueden tener una cláusula else, que se ejecuta solo si el bucle termina sin haber sido interrumpido por un break.

    Ejemplo:


    for i in range(5):
        print(i)
    else:
        print("Bucle terminado")  # Se ejecuta solo si no se usa un break


BUCLES ANIDADOS:

    Es posible tener bucles dentro de todos los bucles. Es util cuando trabajas con estructuras de datos mas complejas, como matrices o listas de listas.

    for i in range(3):
        for j in range(2):
            print(f"i: {i}, j: {j}")

            -El bucle externo (para i) itera 3 veces (de 0 a 2).
            -Por cada iteración de i, el bucle interno (para j) itera 2 veces (de 0 a 1).
            -Así que el total de iteraciones es 3 * 2 = 6, y por eso se imprimen 6 líneas.



    EXPLICACION DETALLADA:

        1. Cuando i = 0:
            
            El segundo bucle comienza y j toma los valores 0 y 1.
            Primero se imprime: i: 0, j: 0.
            Luego se imprime: i: 0, j: 1.

        2. Cuando i = 1:

            El segudno bucle vuelve a recorrer range(2) y j toma nuevamente los valores 0 y 1.
            Primero se imprime: i: 1, j: 0.
            Luego se imprime: i: 1, j: 1.

         3. Cuando i = 2:

            El segudno bucle recorre range(2) y j toma nuevamente los valores 0 y 1.
            Primero se imprime: i: 2, j: 0.
            Luego se imprime: i: 2, j: 1.


        i: 0, j: 0
        i: 0, j: 1
        i: 1, j: 0
        i: 1, j: 1
        i: 2, j: 0
        i: 2, j: 1




PASAR NUMEROS A STRING PARA SUMARLOS ENTRE SI O MAS OPERACIONES:

    Calcular la suma de los digitos:

        def digit_sum(num):
        aux = 0  # Inicializamos la variable auxiliar en 0
        for x in str(num):  # Convertimos el número en cadena y recorremos cada dígito
            aux = aux + int(x)  # Convertimos el dígito en entero y lo sumamos a aux
        return aux  # Retornamos la suma total de los dígitos


    Explicación paso a paso:

        Convertimos el número en una cadena (str(num)) para poder recorrer sus dígitos individualmente.
        Iteramos sobre cada dígito con un for que recorre los caracteres de la cadena.
        Convertimos cada carácter a entero (int(x)) y lo sumamos a la variable aux.
        Retornamos el valor total de la suma de los dígitos.

    Luego en este paso nos puede dar un error si el numero es negativo, entonces a la linea de str(num) le añadimos abs (str(abs(num))) esto sirve para
    evitar el signo negativo.

    Tambien se puede escribir en una sola linea:

        def digit_sum(num):
            return sum(int(x) for x in str(abs(num)))



MATH:


Categoría:	Funciones principales
Redondeo:	ceil, floor, trunc, round
Potencias y logaritmos:	pow, sqrt, exp, log, log10, log2
Trigonometría:	sin, cos, tan, asin, acos, atan, radians, degrees
Combinatoria:	factorial, gcd, lcm, comb, perm
Constantes:	pi, e, tau, inf, nan

Hay varios tipos de math:

    Para redondear hay varios tipos:
        
    math.ceil(x) → Redondea hacia arriba al entero más cercano.
    math.floor(x) → Redondea hacia abajo al entero más cercano.
    math.trunc(x) → Elimina la parte decimal, dejando solo la parte entera.
    round(x, n) → Redondea x a n decimales (no pertenece a math, pero es útil).

    import math
print(math.ceil(4.3))   # 5
print(math.floor(4.7))  # 4
print(math.trunc(4.9))  # 4
print(round(4.567, 2))  # 4.57



FUNCIONES DE POTENCIAS Y LOGARITMICOS
math.pow(x, y) → Calcula 
x
y
x 
y
  (similar a x ** y).
math.sqrt(x) → Raíz cuadrada de x.
math.exp(x) → Calcula 
e
x
e 
x
  (exponencial).
math.log(x) → Logaritmo natural 
ln
⁡
(
x
)
ln(x).
math.log(x, base) → Logaritmo en una base específica.
math.log10(x) → Logaritmo en base 10.
math.log2(x) → Logaritmo en base 2.

Ejemplo:

print(math.pow(2, 3))   # 8.0
print(math.sqrt(25))    # 5.0
print(math.exp(2))      # 7.38905609893065 (e^2)
print(math.log(10))     # 2.302585092994046 (ln 10)
print(math.log(100, 10))# 2.0 (logaritmo base 10 de 100)





FUNCIONES TRIGONOMETRICAS

math.sin(x), math.cos(x), math.tan(x) → Seno, coseno y tangente (en radianes).
math.asin(x), math.acos(x), math.atan(x) → Funciones trigonométricas inversas.
math.degrees(x) → Convierte radianes a grados.
math.radians(x) → Convierte grados a radianes.

Ejemplo:

print(math.sin(math.radians(30)))  # 0.5
print(math.cos(math.radians(60)))  # 0.5
print(math.tan(math.radians(45)))  # 1.0
print(math.degrees(math.pi))       # 180.0



FUNCIONES FACTORIALES Y COMBINATORIAS
math.factorial(n) → Calcula el factorial de n (
n
!
n!).
math.gcd(a, b) → Máximo común divisor (MCD).
math.lcm(a, b) → Mínimo común múltiplo (MCM) (Python 3.9+).
math.comb(n, k) → Número de combinaciones 
C
(
n
,
k
)
C(n,k) (Python 3.8+).
math.perm(n, k) → Número de permutaciones 
P
(
n
,
k
)
P(n,k) (Python 3.8+).

Ejemplo:

print(math.factorial(5))  # 120 (5! = 5×4×3×2×1)
print(math.gcd(24, 36))   # 12 (MCD de 24 y 36)
print(math.lcm(4, 6))     # 12 (MCM de 4 y 6)
print(math.comb(5, 2))    # 10 (Combinaciones de 5 elementos tomados de 2 en 2)
print(math.perm(5, 2))    # 20 (Permutaciones de 5 elementos tomados de 2 en 2)



CONSTANTES MATEMATICAS
math.pi → Aproximación de π (3.141592653589793).
math.e → Número de Euler 
e
e (2.718281828459045).
math.tau → 
τ
τ (2π).
math.inf → Representa infinito (float('inf')).
math.nan → Representa "Not a Number" (float('nan')).

Ejemplo:

print(math.pi)   # 3.141592653589793
print(math.e)    # 2.718281828459045
print(math.tau)  # 6.283185307179586
print(math.inf > 1000000)  # True
print(math.isnan(float('nan')))  # True




FACTORIZAR:

El factorial de un numero entero positivo n se define como el producto de todos los numeros enteros desde 1 hasta n.
Se representa con el simbolo !n.

Se coge esat formula para cualquier numero: n!=n×(n−1)×(n−2)×...×2×1 hasta que llegue a 1 y ahi ya se para.
Es decir si el numero fuera 5 seria:

                5!: 5 x 4 = 20   
                    20 x 3 = 60
                    60 x 2 = 120
                    120 x 1 = 120

                    Entonces 120 seria el resultado de factorizar el 5


                i = 1 → result = 1 * 1 = 1
                i = 2 → result = 1 * 2 = 2
                i = 3 → result = 2 * 3 = 6
                i = 4 → result = 6 * 4 = 24
                i = 5 → result = 24 * 5 = 120